using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using PFModels.Meta;
using PFModels.Properties;

namespace PFModels.Repositories
{
    /// <summary>
    ///     Holds Information about each Option like it's code, text, default value and tooltip.
    /// </summary>
    public class OptionsMetaRepository
    {
        /// <summary>
        ///     Used for ease in (De)Serialization of Dictionary
        /// </summary>
        public class OptionMetaRepositoryItem
        {
            public string Key { get; set; }
            public OptionMeta Value { get; set; }
        }

        protected static Dictionary<string, OptionMeta> _repositoryItems;

        static OptionsMetaRepository()
        {
            _repositoryItems = new Dictionary<string, OptionMeta>();

            if (!File.Exists(Environment.CurrentDirectory + "\\OptionsRepository.xml"))
            {
                string fileInfo = Resources.OptionsRepository;
                File.WriteAllText(Environment.CurrentDirectory + "\\OptionsRepository.xml", fileInfo);
            }

            var data = TextSerializer.XmlDeserializeFromString<OptionMetaRepositoryItem[]>(File.ReadAllText(Environment.CurrentDirectory + "\\OptionsRepository.xml"));
            foreach (var item in data)
                _repositoryItems.Add(item.Key, item.Value);

            #region Hardcode

            //_repositoryItems.Add("Block Policy", new OptionMeta()
            //            {
            //                Key = "Block Policy",
            //                Code = "block-policy",
            //                Text = "Block Policy",
            //                Default = "drop",
            //                Tooltip = "Sets the default behavior for filter rules that specify the block action.",
            //                ContainsOptions = true,
            //                FreeInput = false,
            //                Options = new ObservableCollection<object>(new List<object> { "drop", "return" })
            //            });

            //_repositoryItems.Add("State Policy", new OptionMeta()
            //{
            //    Key = "State Policy",
            //    Code = "state-policy",
            //    Text = "State Policy",
            //    Default = "floating",
            //    Tooltip = "Sets PF's behavior when it comes to keeping state. This behavior can be overridden on a per rule basis.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "if-bound", "floating" })
            //});

            //_repositoryItems.Add("Debug Level", new OptionMeta()
            //{
            //    Key = "Debug Level",
            //    Code = "debug",
            //    Text = "Debug Level",
            //    Default = "urgent",
            //    Tooltip = "Set pf's debugging level.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "none", "urgent", "misc", "loud" })
            //});

            //_repositoryItems.Add("Fingerprints", new OptionMeta()
            //{
            //    Key = "Fingerprints",
            //    Code = "fingerprints",
            //    Text = "Fingerprints File",
            //    Default = "/etc/pf.os",
            //    Tooltip = "Sets the file to load operating system fingerprints from. For use with passive OS fingerprinting.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.NotEmptyText}
            //});

            //_repositoryItems.Add("Frags", new OptionMeta()
            //{
            //    Key = "Frags",
            //    Code = "limit frags",
            //    Text = "Frags Limit",
            //    Default = "5000",
            //    Tooltip = "maximum number of entries in the memory pool used for packet reassembly (scrub rules).",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("Src-Nodes", new OptionMeta()
            //{
            //    Key = "Src-Nodes",
            //    Code = "limit src-nodes",
            //    Text = "Source Nodes",
            //    Default = "10000",
            //    Tooltip = "maximum number of entries in the memory pool used for tracking source IP addresses (generated by the sticky-address and source-track options).",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("States", new OptionMeta()
            //{
            //    Key = "States",
            //    Code = "limit states",
            //    Text = "States",
            //    Default = "10000",
            //    Tooltip = "maximum number of entries in the memory pool used for state table entries (filter rules that specify keep state).",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("Tables", new OptionMeta()
            //{
            //    Key = "Tables",
            //    Code = "limit tables",
            //    Text = "Tables",
            //    Default = "1000",
            //    Tooltip = "maximum number of tables that can be created.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("Table-Entries", new OptionMeta()
            //{
            //    Key = "Table-Entries",
            //    Code = "limit table-entries",
            //    Text = "Table-Entries",
            //    Default = "100000",
            //    Tooltip = "the overall limit on how many addresses can be stored in all tables.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("Optimization", new OptionMeta()
            //{
            //    Key = "Optimization",
            //    Code = "optimization",
            //    Text = "Optimization Mode",
            //    Default = "normal",
            //    Tooltip = "Optimize PF for one of the network environments.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "normal", "high-latency", "aggressive", "conservative" })
            //});

            //_repositoryItems.Add("Ruleset-Optimization", new OptionMeta()
            //{
            //    Key = "Ruleset-Optimization",
            //    Code = "ruleset-optimization",
            //    Text = "Ruleset Optimization",
            //    Default = "basic",
            //    Tooltip = "Control operation of the PF ruleset optimizer.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "none", "basic", "profile" })
            //});

            //_repositoryItems.Add("Loginterface", new OptionMeta()
            //{
            //    Key = "Loginterface",
            //    Code = "loginterface",
            //    Text = "Loginterface",
            //    Default = "none",
            //    Tooltip = "Sets the interface for which PF should gather statistics such as bytes in, out and packets passed/blocked. Statistics can only be gathered for one interface at a time. Note that the match, bad-offset, etc., counters and the state table counters are recorded regardless of whether loginterface is set or not. To turn this option off, set it to none.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "none" })
            //});

            //_repositoryItems.Add("SkipOn", new OptionMeta()
            //{
            //    Key = "SkipOn",
            //    Code = "skip on",
            //    Text = "Skip On",
            //    Default = "none",
            //    Tooltip = "Skip all PF processing on interface. This can be useful on loopback interfaces where filtering, normalization, queueing, etc, are not required. This option can be used multiple times.",
            //    ContainsOptions = true,
            //    FreeInput = false,
            //    Options = new ObservableCollection<object>(new List<object> { "none" })
            //});

            //_repositoryItems.Add("Interval", new OptionMeta()
            //{
            //    Key = "Interval",
            //    Code = "timeout interval",
            //    Text = "Interval",
            //    Default = "10",
            //    Tooltip = "seconds between purges of expired states and packet fragments.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("Frag", new OptionMeta()
            //{
            //    Key = "Frag",
            //    Code = "timeout frag",
            //    Text = "Frag",
            //    Default = "30",
            //    Tooltip = "seconds before an unassembled fragment is expired.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //_repositoryItems.Add("SrcTrack", new OptionMeta()
            //{
            //    Key = "SrcTrack",
            //    Code = "timeout src.track",
            //    Text = "Source Tracking",
            //    Default = "0",
            //    Tooltip = "seconds to keep a source tracking entry in memory after the last state expires.",
            //    ContainsOptions = false,
            //    FreeInput = true,
            //    Rules = new List<ValidationRule>() { ValidationRule.PositiveInt }
            //});

            //string data = TextSerializer.XmlSerializeToString(_repositoryItems.Select(pair => new OptionMetaRepositoryItem { Key = pair.Key, Value = pair.Value as OptionMeta }).ToArray());
            //File.WriteAllText(Environment.CurrentDirectory + "\\OptionsRepository.xml", data);

            #endregion
        }

        public static OptionMeta GetItem(string key)
        {
            return _repositoryItems[key];
        }

        public static List<OptionMeta> GetMetas()
        {
            return _repositoryItems.Values.ToList();
        }
    }
}